import StyleDictionary from 'style-dictionary';
import type { TransformedToken, Config } from 'style-dictionary/types';
import { registerTransforms } from './transforms/flutter.js';

// Register custom Flutter transforms
registerTransforms(StyleDictionary);

// Helper to convert hex to Flutter Color format
function hexToFlutterColor(hex: string): string {
  const cleanHex = hex.replace('#', '');
  if (cleanHex.length === 6) {
    return `0xFF${cleanHex.toUpperCase()}`;
  }
  return `0x${cleanHex.toUpperCase()}`;
}

// Custom format for Flutter/Dart
StyleDictionary.registerFormat({
  name: 'flutter/tokens.dart',
  format: function ({ dictionary }) {
    const header = `// DO NOT EDIT - Auto-generated by Style Dictionary
// Generated at: ${new Date().toISOString()}

import 'package:flutter/material.dart';

`;

    // Group tokens by category
    const colors = dictionary.allTokens.filter(
      (t) => t.type === 'color' || t.path[0] === 'color'
    );
    const spacing = dictionary.allTokens.filter(
      (t) => t.type === 'spacing' || t.path[0] === 'spacing'
    );
    const typography = dictionary.allTokens.filter((t) => t.path[0] === 'typography');
    const borderRadius = dictionary.allTokens.filter(
      (t) => t.type === 'borderRadius' || t.path[0] === 'borderRadius'
    );
    const transitions = dictionary.allTokens.filter(
      (t) => t.type === 'transition' || t.path[0] === 'transition'
    );

    let output = header;

    // Colors class
    output += `/// Design system color tokens
abstract class DsColors {
`;
    colors.forEach((token) => {
      const name = token.path
        .slice(1)
        .map((p, i) => (i === 0 ? p : p.charAt(0).toUpperCase() + p.slice(1)))
        .join('');
      const colorValue = hexToFlutterColor(token.value as string);
      output += `  static const Color ${name} = Color(${colorValue});\n`;
    });
    output += `}\n\n`;

    // Spacing class
    output += `/// Design system spacing tokens
abstract class DsSpacing {
`;
    spacing.forEach((token) => {
      const name = `space${token.path[1]}`;
      const value = parseFloat(token.value as string);
      output += `  static const double ${name} = ${value};\n`;
    });
    output += `}\n\n`;

    // Typography classes
    output += `/// Design system typography tokens
abstract class DsTypography {
`;
    const fontFamilies = typography.filter((t) => t.path[1] === 'fontFamily');
    const fontSizes = typography.filter((t) => t.path[1] === 'fontSize');
    const fontWeights = typography.filter((t) => t.path[1] === 'fontWeight');
    const lineHeights = typography.filter((t) => t.path[1] === 'lineHeight');

    fontFamilies.forEach((token) => {
      const name = `fontFamily${token.path[2].charAt(0).toUpperCase() + token.path[2].slice(1)}`;
      const value = (token.value as string).split(',')[0].replace(/'/g, '');
      output += `  static const String ${name} = '${value}';\n`;
    });
    fontSizes.forEach((token) => {
      const name = `fontSize${token.path[2].charAt(0).toUpperCase() + token.path[2].slice(1)}`;
      const value = parseFloat(token.value as string);
      output += `  static const double ${name} = ${value};\n`;
    });
    fontWeights.forEach((token) => {
      const name = `fontWeight${token.path[2].charAt(0).toUpperCase() + token.path[2].slice(1)}`;
      output += `  static const FontWeight ${name} = FontWeight.w${token.value};\n`;
    });
    lineHeights.forEach((token) => {
      const name = `lineHeight${token.path[2].charAt(0).toUpperCase() + token.path[2].slice(1)}`;
      output += `  static const double ${name} = ${token.value};\n`;
    });
    output += `}\n\n`;

    // Border radius class
    output += `/// Design system border radius tokens
abstract class DsBorderRadius {
`;
    borderRadius.forEach((token) => {
      const name = token.path[1];
      const value = parseFloat(token.value as string);
      output += `  static const double ${name} = ${value};\n`;
      output += `  static BorderRadius ${name}All = BorderRadius.circular(${value});\n`;
    });
    output += `}\n\n`;

    // Transitions class (as Duration)
    output += `/// Design system transition/animation duration tokens
abstract class DsTransitions {
`;
    transitions.forEach((token) => {
      const name = token.path[1];
      const ms = parseInt(token.value as string);
      output += `  static const Duration ${name} = Duration(milliseconds: ${ms});\n`;
    });
    output += `}\n`;

    return output;
  }
});

// Custom format for TypeScript with proper types
StyleDictionary.registerFormat({
  name: 'typescript/tokens',
  format: function ({ dictionary }) {
    let output = `// DO NOT EDIT - Auto-generated by Style Dictionary
// Generated at: ${new Date().toISOString()}

`;

    // Export colors
    output += `export const colors = {\n`;
    const colors = dictionary.allTokens.filter((t) => t.path[0] === 'color');
    const colorGroups: Record<string, Record<string, string>> = {};
    colors.forEach((token) => {
      const group = token.path[1];
      if (!colorGroups[group]) colorGroups[group] = {};
      const key = token.path.slice(2).join('_') || 'default';
      colorGroups[group][key] = token.value as string;
    });
    Object.entries(colorGroups).forEach(([group, values]) => {
      output += `  ${group}: {\n`;
      Object.entries(values).forEach(([key, value]) => {
        output += `    '${key}': '${value}',\n`;
      });
      output += `  },\n`;
    });
    output += `} as const;\n\n`;

    // Export spacing
    output += `export const spacing = {\n`;
    dictionary.allTokens
      .filter((t) => t.path[0] === 'spacing')
      .forEach((token) => {
        output += `  '${token.path[1]}': '${token.value}',\n`;
      });
    output += `} as const;\n\n`;

    // Export typography
    output += `export const typography = {\n`;
    const typo = dictionary.allTokens.filter((t) => t.path[0] === 'typography');
    const typoGroups: Record<string, Record<string, string>> = {};
    typo.forEach((token) => {
      const group = token.path[1];
      if (!typoGroups[group]) typoGroups[group] = {};
      typoGroups[group][token.path[2]] = token.value as string;
    });
    Object.entries(typoGroups).forEach(([group, values]) => {
      output += `  ${group}: {\n`;
      Object.entries(values).forEach(([key, value]) => {
        output += `    ${key}: '${value}',\n`;
      });
      output += `  },\n`;
    });
    output += `} as const;\n\n`;

    // Export borderRadius
    output += `export const borderRadius = {\n`;
    dictionary.allTokens
      .filter((t) => t.path[0] === 'borderRadius')
      .forEach((token) => {
        output += `  ${token.path[1]}: '${token.value}',\n`;
      });
    output += `} as const;\n\n`;

    // Export shadows
    output += `export const shadows = {\n`;
    dictionary.allTokens
      .filter((t) => t.path[0] === 'shadow')
      .forEach((token) => {
        output += `  ${token.path[1]}: '${token.value}',\n`;
      });
    output += `} as const;\n\n`;

    // Export transitions
    output += `export const transitions = {\n`;
    dictionary.allTokens
      .filter((t) => t.path[0] === 'transition')
      .forEach((token) => {
        output += `  ${token.path[1]}: '${token.value}',\n`;
      });
    output += `} as const;\n\n`;

    // Export zIndex
    output += `export const zIndex = {\n`;
    dictionary.allTokens
      .filter((t) => t.path[0] === 'zIndex')
      .forEach((token) => {
        output += `  ${token.path[1]}: ${token.value},\n`;
      });
    output += `} as const;\n\n`;

    // Export all tokens
    output += `export const tokens = {
  colors,
  spacing,
  typography,
  borderRadius,
  shadows,
  transitions,
  zIndex,
} as const;

export type Tokens = typeof tokens;
export default tokens;
`;

    return output;
  }
});

// Build configuration
const config: Config = {
  source: ['src/**/*.json'],
  platforms: {
    css: {
      transformGroup: 'css',
      buildPath: 'build/css/',
      prefix: 'ds',
      files: [
        {
          destination: 'variables.css',
          format: 'css/variables',
          options: {
            outputReferences: true
          }
        }
      ]
    },
    scss: {
      transformGroup: 'scss',
      buildPath: 'build/scss/',
      prefix: 'ds',
      files: [
        {
          destination: '_variables.scss',
          format: 'scss/variables',
          options: {
            outputReferences: true
          }
        }
      ]
    },
    typescript: {
      transformGroup: 'js',
      buildPath: 'build/ts/',
      files: [
        {
          destination: 'index.ts',
          format: 'typescript/tokens'
        }
      ]
    },
    dart: {
      transformGroup: 'flutter',
      buildPath: 'build/dart/',
      files: [
        {
          destination: 'tokens.dart',
          format: 'flutter/tokens.dart'
        }
      ]
    }
  }
};

// Run the build
async function build(): Promise<void> {
  console.log('Building design tokens...');

  try {
    const sd = new StyleDictionary(config);
    await sd.buildAllPlatforms();
    console.log('\n✅ Tokens built successfully!');
    console.log('   - CSS: build/css/variables.css');
    console.log('   - SCSS: build/scss/_variables.scss');
    console.log('   - TypeScript: build/ts/index.ts');
    console.log('   - Dart: build/dart/tokens.dart');
  } catch (error) {
    console.error('❌ Build failed:', error instanceof Error ? error.message : error);
    process.exit(1);
  }
}

build();

